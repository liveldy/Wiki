---
title: 查找
subtitle: 线性查找、树查找、散列表
description: 集合与线性结构
---

# 查找

**查找**是在记录序列中找出满足给定条件的记录。给定的查找条件可以是多种多样的，包括最常见的查找关键码等于给定值，称为**匹配**。通常，若找到了给定值相匹配的记录，则返回它的位置或值；若没有找到给定值相匹配的记录，则返回空指针或0。不涉及插入和删除的查找称为**静态查找**，反之称为**动态查找**，换言之，静态查找不会改变待查找的记录序列，动态查找会改变待查找的记录序列。为了提高查找效率，专门为查找操作设计的数据结构称为**查找结构**。

将查找算法进行的关键码比较次数的数学期望值定义为平均查找长度，对于查找成功的情况，有：

$$
ASL=\sum_{i=1}^np_ic_i
$$

其中，$n$为问题规模，查找集合中的记录个数，$p_i$为查找第$i$个记录的概率，$c_i$为查找第$i$个记录所需的关键码的比较次数。

## 线性查找

### 顺序查找

线性表的查找方式采用**顺序查找**，又称为线性查找，是最基本的查找方法，即从线性表的一端向另一端逐个将关键码与给定值进行比较，若相等，则查找成功，给出该元素在表中的位置，若整个表检测完仍未找到与给定值相等的关键码，则查找失败。

对于有$n$个记录的顺序表，查找第$i$个记录时，设每个记录的查找概率相等，在查找成功时需进行$n-i+1$次关键码的比较：

$$
ASL=\sum_{i=1}^n\frac{1}{n}(n-i+1)=\frac{n+1}{2}
$$

在查找不成功时需进行$n+1$次关键码的比较：

$$
ASL=\sum_{i=1}^n\frac{1}{n}(n+1)=n+1
$$

### 折半查找

如果线性表中的元素的排列有序，则可以采用折半查找，且折半查找一般只应用于静态查找。折半查找的思想类似于二分法，


## 树查找

## 散列表

**散列表（Hash Table）**又称为**哈希表**，是一种以键值形式（key - value）存储数据的数据结构，由于每个数据元素之间没有任何关系，属于集合。在数据元素存储的位置和它的关键码之间建立一个确定的对应关系，使得每个关键码（key）和唯一的存储位置相对应。可以认为散列表是一种高级的数组，这种数组的下标可以是整数、浮点数、字符串、甚至是结构体。使用散列表查找数据元素的技术称为**散列技术**，将关键码映射为散列表中位置的函数称为**散列函数（Hash Function）**，也称为**哈希函数**，所得的存储地址称为**散列地址（Hash Address）**。可以表述为：

对于一个记录集合$T=\{r_1,r_2,...,r_i\}$，有$L=\{Add(r_1)=H(k_1),Add(r_2)=H(k_2),...,Add(r_i)=H(k_i)\}$，则称$H$为散列函数，$L$为散列表，其中，$k_1,k_2,...,k_i(k_1 \neq k_2 \neq ... \neq k_i)$为关键码，散列表的长度为$m$。如果对于两个不同的关键码$k_a \neq k_b$，有$H(k_a)=H(k_b)$，这种现象称为**冲突**，此时$k_a$和$k_b$称为**同义词**。

散列表的装填因子是指散列表被装满的程度，其定义式为：

$$
\alpha = \frac{n}{m}
$$

其中$n$是指已经填入表的记录个数，空散列表的装填因子为0，满散列表的装填因子为1，一个散列表的装填因子越接近1，其冲突出现的概率就越大。

### 散列函数

需要设计一个简单、均匀、存储效率高的散列函数，对于不可避免的冲突，需要采取合适的方法解决冲突。理想情况下的散列称为**完美散列**，完美散列的查找效率是最好的，因为它总会在散列函数计算出的位置上找到待查记录，即只需一次访问。

#### 直接定址法

**直接定址法**的散列函数是关键码的线性函数，即：

$$
H(k)=ak+b(a,b为常数)
$$

直接定址法的特点是单调、均匀，不会产生冲突，但实际中能使用这种散列函数的情况很少。它适用于事先知道关键码的分布，且关键码集合不是很大且连续性较好的情况。

#### 除留余数法

**除留余数法**是选择某个适当的正整数$p$，以关键码除以$p$的余数作为散列地址，即：

$$
H(k)=k\ mod\ p
$$

这一方法的关键在于选取合适的$p$，若选的不好，容易产生同义词，通常选$p$为小于或等于表长的最小质数或不包含小于20质因子的合数。

除留余数法是一种最简单、最常用的构造散列函数的方法，且这种方法不需要事先知道关键码的分布。

#### 数字分析法

**数字分析法**根据关键码在各个位上的分布情况，选取分布比较均匀的若干位组成散列地址。

数字分析法适合于事先知道关键码的分布且关键码中有若干位分布较均匀的情况。

#### 平方取中法

**平方取中法**是对关键码平方后，按散列表大小，取中间的若干位作为散列地址。由于一个数平方后，中间几位分布均匀，也就是不同的关键码发生冲突的情况少。

平方折中法通常用在事先不知道关键码的分布且关键码的位数不是很大的情况，比如有些编译器对标识符的管理采用的就是这种方法。

#### 折叠法

**折叠法**是将关键码从左到右割成位数相等的几部分，最后一部分位数可以短些，然后将这几部分叠加求和，并按散列表表长，取最后几位做散列地址。通常有两种叠加方法：

1. 移位相加：将各部分的最后一位对齐相加
2. 间界相加：从一端向另一端沿各部分分界来回折叠后，最后一位对齐相加。

折叠法适用于关键码的位数很多，且关键码的每一位分布都不均匀的情况。折叠法事先不需要知道关键码的分布。

### 冲突解决方法

#### 开放定址法

**开放定址法**也称为**闭散列法**，处理冲突得到的散列表称为**闭散列表**。开放定址法就是由关键码得到的散列地址一旦产生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到。

##### 线性探测法

当发生冲突时，**线性探测法**寻找的下一个散列地址为：

$$
H_i=(H(k)+d_i)\%m\ \ (i=1,2,...,m-1,d_i=1,2,...,m-1)
$$

线性探测法查找成功时：

$$
ASL=\frac{1}{2}(1+\frac{1}{1-\alpha})
$$

线性探测法查找失败时：

$$
ASL=\frac{1}{2}(1+\frac{1}{(1-\alpha)^2})
$$

线性探测法的弊端也很明显，几个本不是同义词的记录容易争夺同一个散列地址，这种现象称为**堆积**，堆积大大降低了查找效率。

##### 二次探测法

当发生冲突时，**二次探测法**寻找的下一个散列地址为：

$$
H_i=(H(k)+d_i)\%m\ \ (i=1,2,...,m-1,d_i=1^2,-1^2,2^2,-2^2,...,q^2,-q^2,q \leq \sqrt{m})
$$

二次探测法查找成功时：

$$
ASL=-\frac{1}{\alpha}\ln(1+\alpha)
$$

二次探测法查找失败时：

$$
ASL=\frac{1}{1-\alpha}
$$

##### 随机探测法

当发生冲突时，**随机探测法**寻找的下一个散列地址为：

$$
H_i=(H(k)+d_i)\%m\ \ (i=1,2,...,m-1,d_i是一个随机数列)
$$

随机探测法查找成功时：

$$
ASL=1+\frac{\alpha}{2}
$$

随机探测法查找失败时：

$$
ASL=\alpha+e^{-\alpha}
$$

#### 链地址法

**链地址法**也称为**拉链法**、**开散列法**，处理冲突得到的散列表称为**开散列表**。链地址法就是将所有散列地址相同的记录，即所有关键码为同义词的记录存储在一个单链表中，称为同义词子表，在散列表中存储的是所有同义词子表的头指针。